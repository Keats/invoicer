{
  "name": "tslint",
  "version": "0.4.7",
  "description": "a static analysis linter for TypeScript",
  "bin": {
    "tslint": "./bin/tslint"
  },
  "main": "./lib/tslint",
  "repository": {
    "type": "git",
    "url": "https://github.com/palantir/tslint.git"
  },
  "keywords": [
    "cli",
    "typescript",
    "linter"
  ],
  "scripts": {
    "test": "grunt"
  },
  "dependencies": {
    "optimist": "~0.6.0",
    "underscore.string": "~2.3.3",
    "findup-sync": "~0.1.2"
  },
  "devDependencies": {
    "chai": "~1.7.2",
    "grunt": "~0.4.1",
    "grunt-cli": "~0.1.9",
    "grunt-contrib-clean": "~0.5.0",
    "grunt-mocha-test": "~0.6.2",
    "grunt-tslint": "~0.4.0",
    "grunt-ts": "~1.7.2"
  },
  "license": "Apache 2.0",
  "readme": "TSLint [![NPM version](https://badge.fury.io/js/tslint.png)](http://badge.fury.io/js/tslint) [![Builds](https://api.travis-ci.org/repositories/palantir/tslint.png?branch=master)](https://travis-ci.org/palantir/tslint)\n======\n\nA linter for the TypeScript language.\n\nSupported Rules\n-----\n\nA sample configuration file with all options is available [here](https://github.com/palantir/tslint/blob/master/docs/sample.tslint.json).\n\n* `ban` bans the use of specific functions. Options are [\"object\", \"function\"] pairs that ban the use of object.function()\n* `class-name` enforces PascalCased class and interface names.\n* `comment-format` enforces rules for single-line comments. Rule options:\n    * `\"check-space\"` enforces the rule that all single-line comments must begin with a space, as in `// comment`\n        * note that comments starting with `///` are also allowed, for things such as ///<reference>\n    * `\"check-lowercase\"` enforces the rule that the first non-whitespace character of a comment must be lowercase, if applicable\n* `curly` enforces braces for `if`/`for`/`do`/`while` statements.\n* `eofline` enforces the file to end with a newline.\n* `forin` enforces a `for ... in` statement to be filtered with an `if` statement.*\n* `indent` enforces consistent indentation levels (currently disabled).\n* `interface-name` enforces the rule that interface names must begin with a capital 'I'\n* `jsdoc-format` enforces basic format rules for jsdoc comments -- comments starting with `/**`\n    * each line contains an asterisk and asterisks must be aligned\n    * each asterisk must be followed by either a space or a newline (except for the first and the last)\n    * the only characters before the asterisk on each line must be whitepace characters\n* `label-position` enforces labels only on sensible statements.\n* `label-undefined` checks that labels are defined before usage.\n* `max-line-length` sets the maximum length of a line.\n* `no-arg` disallows access to `arguments.callee`.\n* `no-bitwise` disallows bitwise operators.\n* `no-console` disallows access to the specified functions on `console`. Rule options are functions to ban on the console variable.\n* `no-consecutive-blank-lines` disallows having more than one blank line in a row in a file\n* `no-construct` disallows access to the constructors of `String`, `Number`, and `Boolean`.\n* `no-debugger` disallows `debugger` statements.\n* `no-duplicate-key` disallows duplicate keys in object literals.\n* `no-duplicate-variable` disallows duplicate variable declarations.\n* `no-empty` disallows empty blocks.\n* `no-eval` disallows `eval` function invocations.\n* `no-string-literal` disallows object access via string literals.\n* `no-trailing-comma` disallows trailing comma within object literals.\n* `no-trailing-whitespace` disallows trailing whitespace at the end of a line.\n* `no-unused-expression` disallows unused expression statements, that is, expression statements that are not assignments or function invocations (and thus no-ops).\n* `no-unused-variable` disallows unused imports, variables, functions and private class members.\n    * `\"check-parameters\"` disallows unused function and constructor parameters.\n        * NOTE: this option is experimental and does not work with classes that use abstract method declarations, among other things. Use at your own risk.\n* `no-unreachable` disallows unreachable code after `break`, `catch`, `throw`, and `return` statements.\n* `no-use-before-declare` disallows usage of variables before their declaration.\n* `one-line` enforces the specified tokens to be on the same line as the expression preceding it. Rule options:\n\t* `\"check-catch\"` checks that `catch` is on the same line as the closing brace for `try`\n\t* `\"check-else\"` checks that `else` is on the same line as the closing brace for `if`\n\t* `\"check-open-brace\"` checks that an open brace falls on the same line as its preceding expression.\n\t* `\"check-whitespace\"` checks preceding whitespace for the specified tokens.\n* `quotemark` enforces consistent single or double quoted string literals.\n* `radix` enforces the radix parameter of `parseInt`\n* `semicolon` enforces semicolons at the end of every statement.\n* `triple-equals` enforces === and !== in favor of == and !=.\n* `typedef` enforces type definitions to exist. Rule options:\n    * `\"callSignature\"` checks return type of functions\n    * `\"catchClause\"` checks type in exception catch blocks\n    * `\"indexSignature\"` checks index type specifier of indexers\n    * `\"parameter\"` checks type specifier of parameters\n    * `\"propertySignature\"` checks return types of interface properties\n    * `\"variableDeclarator\"` checks variable declarations\n* `typedef-whitespace` enforces spacing whitespace for type definitions. Each rule option requires a value of `\"space\"` or `\"nospace\"`\n   to require a space or no space before the type specifier's colon. Rule options:\n    * `\"callSignature\"` checks return type of functions\n    * `\"catchClause\"` checks type in exception catch blocks\n    * `\"indexSignature\"` checks index type specifier of indexers\n* `use-strict` enforces ECMAScript 5's strict mode\n    * `check-module` checks that all top-level modules are using strict mode\n    * `check-function` checks that all top-level functions are using strict mode\n* `variable-name` allows only camelCased or UPPER_CASED variable names. Rule options:\n\t* `\"allow-leading-underscore\"` allows underscores at the beginnning.\n* `whitespace` enforces spacing whitespace. Rule options:\n\t* `\"check-branch\"` checks branching statements (`if`/`else`/`for`/`while`) are followed by whitespace\n\t* `\"check-decl\"`checks that variable declarations have whitespace around the equals token\n\t* `\"check-operator\"` checks for whitespace around operator tokens\n\t* `\"check-separator\"` checks for whitespace after separator tokens (`,`/`;`)\n\t* `\"check-type\"` checks for whitespace before a variable type specification\n\nTSLint Rule Flags\n-----\nYou can enable/disable TSLint or a subset of rules within a file with the following comment rule flags:\n\n* `/* tslint:disable */` - Disable all rules for the rest of the file\n* `/* tslint:enable */` - Enable all rules for the rest of the file\n* `/* tslint:disable:rule1 rule2 rule3... */` - Disable the listed rules for the rest of the file\n* `/* tslint:enable:rule1 rule2 rule3... */` - Enable the listed rules for the rest of the file\n\nRules flags enable or disable rules as they are parsed. A rule is enabled or disabled until a later directive commands otherwise. Disabling an already disabled rule or enabling an already enabled rule has no effect.\n\nFor example, imagine the directive `/* tslint:disable */` on the first line of a file, `/* tslint:enable:ban class-name */` on the 10th line and `/* tslint:enable */` on the 20th. No rules will be checked between the 1st and 10th lines, only the `ban` and `class-name` rules will be checked between the 10th and 20th, and all rules will be checked for the remainder of the file.\n\nCustom Rules\n------------\nTSLint ships with a set of core rules that can be configured. However, users are also allowed to write their own rules, which allows them to enforce specific behavior not covered by the core of TSLint. TSLint's internal rules are itself written to be pluggable, so adding a new rule is as simple as creating a new rule file named by convention. New rules can be written in either TypeScript or Javascript; if written in TypeScript, the code must be compiled to Javascript before invoking TSLint.\n\nRule names are always camel-cased and *must* contain the suffix `Rule`. Let us take the example of how to write a new rule to forbid all import statements (you know, *for science*). Let us name the rule file `noImportsRule.ts`. Rules can be referenced in `tslint.json` in their dasherized forms, so `\"no-imports\": true` would turn on the rule.\n\nNow, let us first write the rule in TypeScript. At the top, we reference TSLint's [definition](https://github.com/palantir/tslint/blob/master/lib/tslint.d.ts) file. The exported class name must always be named `Rule` and extend from `Lint.Rules.AbstractRule`.\n\n```javascript\n/// <reference path='tslint.d.ts' />\n\nexport class Rule extends Lint.Rules.AbstractRule {\n\tpublic static FAILURE_STRING = \"import statement forbidden\";\n\n    public apply(syntaxTree: TypeScript.SyntaxTree): Lint.RuleFailure[] {\n        return this.applyWithWalker(new NoImportsWalker(syntaxTree, this.getOptions()));\n    }\n}\n```\n\nThe walker takes care of all the work.\n\n```javascript\nclass NoImportsWalker extends Lint.RuleWalker {\n\tpublic visitImportDeclaration(node: TypeScript.ImportDeclarationSyntax) {\n\t\t// get the current position and skip over any leading whitespace\n\t\tvar position = this.position() + node.leadingTriviaWidth();\n\n\t\t// create a failure at the current position\n\t\tthis.addFailure(this.createFailure(position, node.width(), Rule.FAILURE_STRING));\n\n\t\t// call the base version of this visitor to actually parse this node\n\t\tsuper.visitImportDeclaration(node);\n\t}\n}\n```\n\nGiven a walker, TypeScript's parser visits the AST using the visitor pattern. So the rule walkers only need to override the appropriate visitor methods to enforce its checks. For reference, the base walker can be found in [syntaxWalker.generated.ts](https://github.com/palantir/tslint/blob/master/src/typescript/src/compiler/syntax/syntaxWalker.generated.ts) within the TypeScript source code.\n\nWe still need to hook up this new rule to TSLint. First make sure to compile `noImportsRule.ts`: `tsc -m commonjs noImportsRule.ts tslint.d.ts`. Then, if using the CLI, provide the directory that contains this rule as an option to `--rules-dir`. If using TSLint as a library or via `grunt-tslint`, the `options` hash must contain `\"rulesDirectory\": \"...\"`. If you run the linter, you'll see that we have now successfully banned all import statements via TSLint!\n\nNow, let us rewrite the same rule in Javascript.\n\n```javascript\n\nfunction Rule() {\n    Lint.Rules.AbstractRule.apply(this, arguments);\n}\n\nRule.prototype = Object.create(Lint.Rules.AbstractRule.prototype);\nRule.prototype.apply = function(syntaxTree) {\n    return this.applyWithWalker(new NoImportsWalker(syntaxTree, this.getOptions()));\n};\n\nfunction NoImportsWalker() {\n    Lint.RuleWalker.apply(this, arguments);\n}\n\nNoImportsWalker.prototype = Object.create(Lint.RuleWalker.prototype);\nNoImportsWalker.prototype.visitImportDeclaration = function (node) {\n    // get the current position and skip over any leading whitespace\n    var position = this.position() + node.leadingTriviaWidth();\n\n    // create a failure at the current position\n    this.addFailure(this.createFailure(position, node.width(), \"import statement forbidden\"));\n\n\t// call the base version of this visitor to actually parse this node\n    Lint.RuleWalker.prototype.visitImportDeclaration.call(this, node);\n};\n\nexports.Rule = Rule;\n```\n\nAs you can see, it's a pretty straightforward translation from the equivalent TypeScript code.\n\nFinally, core rules cannot be overwritten with a custom implementation, and rules can also take in options (retrieved via `this.getOptions()`).\n\nCustom Formatters\n-----------------\nJust like rules, additional formatters can also be supplied to TSLint via `--formatters-dir` on the CLI or `formattersDirectory` option on the library or `grunt-tslint`. Writing a new formatter is simpler than writing a new rule, as shown in the JSON formatter's code.\n\n```javascript\n/// <reference path='tslint.d.ts' />\n\nexport class Formatter extends Lint.Formatters.AbstractFormatter {\n    public format(failures: Lint.RuleFailure[]): string {\n        var failuresJSON: any[] = [];\n\n        for (var i = 0; i < failures.length; ++i) {\n            failuresJSON.push(failures[i].toJson());\n        }\n\n        return JSON.stringify(failuresJSON);\n    }\n}\n```\n\nSuch custom formatters can also be written in Javascript. Additionally, formatter files are always named with the suffix `Formatter`, and referenced from TSLint without its suffix.\n\nInstallation\n------------\n\n##### CLI\n\n```sudo npm install tslint -g```\n\n##### Library\n\n```npm install tslint```\n\nUsage\n-----\n\nPlease first ensure that the TypeScript source files compile correctly.\n\n##### CLI\n\n    usage: tslint\n\n\tOptions:\n\t  -c, --config  \t\t configuration file\n\t  -f, --file    \t\t file to lint                 [required]\n\t  -o, --out     \t\t output file\n      -r, --rules-dir   \t rules directory\n      -s, --formatters-dir   formatters directory\n\t  -t, --format  \t\t output format (prose, json)  [default: \"prose\"]\n\nBy default, configuration is loaded from `tslint.json`, if it exists in the current path, or the user's home directory, in that order.\n\ntslint accepts the following commandline options:\n\n    -f, --file:\n        The location of the TypeScript file that you wish to lint. This\n        option is required.\n\n    -c, --config:\n        The location of the configuration file that tslint will use to\n        determine which rules are activated and what options to provide\n        to the rules. If no option is specified, the config file named\n        tslint.json is used, so long as it exists in the path.\n        The format of the file is { rules: { /* rules list */ } },\n        where /* rules list */ is a key: value comma-seperated list of\n        rulename: rule-options pairs. Rule-options can be either a\n        boolean true/false value denoting whether the rule is used or not,\n        or a list [boolean, ...] where the boolean provides the same role\n        as in the non-list case, and the rest of the list are options passed\n        to the rule that will determine what it checks for (such as number\n        of characters for the max-line-length rule, or what functions to ban\n        for the ban rule).\n\n    -o, --out:\n        A filename to output the results to. By default, tslint outputs to\n        stdout, which is usually the console where you're running it from.\n\n    -r, --rules-dir:\n        An additional rules directory, for user-created rules.\n        tslint will always check its default rules directory, in\n        node_modules/tslint/build/rules, before checking the user-provided\n        rules directory, so rules in the user-provided rules directory\n        with the same name as the base rules will not be loaded.\n\n    -s, --formatters-dir:\n        An additional formatters directory, for user-created formatters.\n        Formatters are files that will format the tslint output, before\n        writing it to stdout or the file passed in --out. The default\n        directory, node_modules/tslint/build/formatters, will always be\n        checked first, so user-created formatters with the same names\n        as the base formatters will not be loaded.\n\n    -t, --format:\n        The formatter to use to format the results of the linter before\n        outputting it to stdout or the file passed in --out. The core\n        formatters are prose (human readable) and json (machine readable),\n        and prose is the default if this option is not used. Additional\n        formatters can be added and used if the --formatters-dir option\n        is set.\n\n    --help:\n        Prints this help message.\n\n##### Library\n\n```javascript\nvar options = {\n\tformatter: \"json\",\n\tconfiguration: configuration,\n\trulesDirectory: \"customRules/\",\n\tformattersDirectory: \"customFormatters/\"\n};\n\nvar Linter = require(\"tslint\");\n\nvar ll = new Linter(fileName, contents, options);\nvar result = ll.lint();\n```\n\nDevelopment\n-----------\n\nTo develop tslint simply clone the repository, install dependencies and run grunt:\n\n```bash\ngit clone git@github.com:palantir/tslint.git\nnpm install\ngrunt\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/palantir/tslint/issues"
  },
  "_id": "tslint@0.4.7",
  "_from": "tslint@~0.4.5"
}
